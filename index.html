<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Save Me Ink - Reduce PDF, PowerPoint & Image Ink Usage</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <meta name="theme-color" content="#1a1a2e">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #0f0f1a 0%, #1a1a2e 50%, #16213e 100%);
            min-height: 100vh;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 2rem;
        }

        .container { max-width: 600px; width: 100%; margin-top: 3rem; }

        .logo { text-align: center; margin-bottom: 1rem; }
        .logo-icon { font-size: 4rem; margin-bottom: 0.5rem; filter: drop-shadow(0 0 20px rgba(102, 126, 234, 0.3)); }

        h1 {
            font-size: 2.5rem; font-weight: 700; text-align: center; margin-bottom: 0.5rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
        }

        .tagline { text-align: center; color: #a0a0b0; font-size: 1.1rem; margin-bottom: 2rem; }

        /* Mode Selector */
        .mode-selector {
            display: flex; gap: 0.5rem; margin-bottom: 2rem; padding: 0.25rem;
            background: rgba(255,255,255,0.05); border-radius: 12px;
        }
        .mode-btn {
            flex: 1; padding: 0.75rem 1rem; border: none; border-radius: 10px;
            background: transparent; color: #a0a0b0; font-size: 0.9rem; font-weight: 500;
            cursor: pointer; transition: all 0.3s ease; display: flex; flex-direction: column;
            align-items: center; gap: 0.25rem;
        }
        .mode-btn:hover { color: #fff; background: rgba(255,255,255,0.05); }
        .mode-btn.active { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; }
        .mode-btn .mode-icon { font-size: 1.25rem; }
        .mode-btn .mode-label { font-size: 0.75rem; opacity: 0.8; }

        .upload-zone {
            border: 2px dashed #3a3a5a; border-radius: 16px; padding: 3rem 2rem;
            text-align: center; cursor: pointer; transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.02);
        }
        .upload-zone:hover, .upload-zone.dragover { border-color: #667eea; background: rgba(102, 126, 234, 0.05); transform: scale(1.01); }
        .upload-zone.has-file { border-color: #4ade80; background: rgba(74, 222, 128, 0.05); }
        .upload-zone.processing { pointer-events: none; opacity: 0.7; }

        .upload-icon { font-size: 3rem; margin-bottom: 1rem; }
        .upload-text { font-size: 1.1rem; color: #e0e0e0; margin-bottom: 0.5rem; }
        .upload-hint { font-size: 0.9rem; color: #707080; }

        .supported-formats { display: flex; justify-content: center; gap: 1rem; margin-top: 1rem; }
        .format-badge { background: rgba(102, 126, 234, 0.2); color: #a0a0ff; padding: 0.25rem 0.75rem; border-radius: 20px; font-size: 0.8rem; font-weight: 500; }

        .file-info { display: none; margin-top: 1.5rem; padding: 1rem; background: rgba(255, 255, 255, 0.05); border-radius: 8px; }
        .file-info.visible { display: block; }
        .file-name { font-weight: 500; color: #fff; word-break: break-all; }
        .file-size { font-size: 0.85rem; color: #707080; margin-top: 0.25rem; }
        .file-type { font-size: 0.75rem; color: #667eea; margin-top: 0.25rem; text-transform: uppercase; }

        .btn {
            width: 100%; padding: 1rem 2rem; font-size: 1.1rem; font-weight: 600;
            border: none; border-radius: 12px; cursor: pointer; transition: all 0.3s ease; margin-top: 1.5rem;
        }
        .btn-primary { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; }
        .btn-primary:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3); }
        .btn-primary:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-success { background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%); color: white; }
        .btn-success:hover { transform: translateY(-2px); box-shadow: 0 10px 30px rgba(74, 222, 128, 0.3); }

        .progress-container { display: none; margin-top: 1.5rem; }
        .progress-container.visible { display: block; }
        .progress-bar { height: 8px; background: rgba(255, 255, 255, 0.1); border-radius: 4px; overflow: hidden; }
        .progress-fill { height: 100%; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); width: 0%; transition: width 0.3s ease; }
        .progress-text { text-align: center; margin-top: 0.75rem; color: #a0a0b0; font-size: 0.9rem; }

        .result-container {
            display: none; margin-top: 2rem; padding: 1.5rem;
            background: rgba(74, 222, 128, 0.1); border-radius: 12px; border: 1px solid rgba(74, 222, 128, 0.2);
        }
        .result-container.visible { display: block; }

        .result-stats { display: flex; justify-content: space-around; margin-bottom: 1.5rem; }
        .stat { text-align: center; }
        .stat-value { font-size: 1.5rem; font-weight: 700; color: #4ade80; }
        .stat-label { font-size: 0.85rem; color: #a0a0b0; margin-top: 0.25rem; }

        /* Preview Section */
        .preview-section { display: none; margin-top: 2rem; }
        .preview-section.visible { display: block; }
        .preview-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; }
        .preview-title { font-weight: 600; font-size: 1.1rem; }
        .preview-nav { display: flex; gap: 0.5rem; align-items: center; }
        .preview-nav button { background: rgba(255,255,255,0.1); border: none; color: white; width: 32px; height: 32px; border-radius: 8px; cursor: pointer; font-size: 1rem; }
        .preview-nav button:hover { background: rgba(255,255,255,0.2); }
        .preview-nav button:disabled { opacity: 0.3; cursor: not-allowed; }
        .preview-page-info { font-size: 0.9rem; color: #a0a0b0; min-width: 80px; text-align: center; }

        .preview-container {
            position: relative; border-radius: 12px; overflow: hidden;
            background: #fff; aspect-ratio: 4/3; user-select: none;
        }
        .preview-image { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: contain; background: #fff; }
        .preview-image.after { clip-path: inset(0 0 0 50%); }
        .preview-slider {
            position: absolute; top: 0; bottom: 0; width: 4px; background: #667eea;
            left: 50%; transform: translateX(-50%); cursor: ew-resize; z-index: 10;
        }
        .preview-slider::before {
            content: ''; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 32px; height: 32px; background: #667eea; border-radius: 50%;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }
        .preview-slider::after {
            content: '‚ü∑'; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 14px; font-weight: bold;
        }
        .preview-labels {
            display: flex; justify-content: space-between; margin-top: 0.75rem;
            font-size: 0.85rem; color: #707080;
        }
        .preview-labels span:first-child { color: #f87171; }
        .preview-labels span:last-child { color: #4ade80; }

        .features { margin-top: 4rem; display: grid; grid-template-columns: repeat(3, 1fr); gap: 1.5rem; }
        .feature {
            text-align: center; padding: 1.5rem 1rem;
            background: rgba(255, 255, 255, 0.02); border-radius: 12px; transition: all 0.3s ease;
        }
        .feature:hover { background: rgba(255, 255, 255, 0.05); transform: translateY(-3px); }
        .feature-icon { font-size: 2rem; margin-bottom: 0.75rem; }
        .feature-title { font-weight: 600; margin-bottom: 0.5rem; }
        .feature-desc { font-size: 0.85rem; color: #707080; }

        .error-message {
            display: none; margin-top: 1rem; padding: 1rem;
            background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.2);
            border-radius: 8px; color: #f87171; text-align: center;
        }
        .error-message.visible { display: block; }

        .privacy-note {
            margin-top: 2rem; text-align: center; font-size: 0.85rem; color: #606070;
            padding: 1rem; background: rgba(255, 255, 255, 0.02); border-radius: 8px;
        }
        .privacy-note strong { color: #4ade80; }

        footer { margin-top: auto; padding-top: 4rem; text-align: center; color: #505060; font-size: 0.85rem; }
        footer a { color: #667eea; text-decoration: none; }

        @media (max-width: 600px) {
            .features { grid-template-columns: 1fr; }
            h1 { font-size: 2rem; }
            .container { margin-top: 2rem; }
            .result-stats { flex-direction: column; gap: 1rem; }
            .supported-formats { flex-direction: column; align-items: center; gap: 0.5rem; }
            .mode-selector { flex-direction: column; }
        }

        input[type="file"] { display: none; }
        canvas { display: none; }
    </style>
</head>
<body>
    <div class="container">
        <div class="logo">
            <div class="logo-icon">üñ®Ô∏è</div>
            <h1>Save Me Ink</h1>
        </div>
        <p class="tagline">Convert documents to ink-minimized versions. Save ink, save money.</p>

        <!-- Mode Selector -->
        <div class="mode-selector">
            <button class="mode-btn active" data-mode="outline">
                <span class="mode-icon">‚úèÔ∏è</span>
                <span>Outline</span>
                <span class="mode-label">Edges only</span>
            </button>
            <button class="mode-btn" data-mode="threshold">
                <span class="mode-icon">‚óê</span>
                <span>Threshold</span>
                <span class="mode-label">B&W conversion</span>
            </button>
        </div>

        <div class="upload-zone" id="uploadZone">
            <div class="upload-icon">üìÑ</div>
            <p class="upload-text">Drop your file here or click to upload</p>
            <p class="upload-hint">100% private ‚Äî processed in your browser</p>
            <div class="supported-formats">
                <span class="format-badge">PDF</span>
                <span class="format-badge">PPTX</span>
                <span class="format-badge">PNG</span>
                <span class="format-badge">JPG</span>
            </div>
            <input type="file" id="fileInput" accept=".pdf,.pptx,.png,.jpg,.jpeg,.webp,application/pdf,application/vnd.openxmlformats-officedocument.presentationml.presentation,image/png,image/jpeg,image/webp">
        </div>

        <div class="file-info" id="fileInfo">
            <div class="file-name" id="fileName"></div>
            <div class="file-size" id="fileSize"></div>
            <div class="file-type" id="fileType"></div>
        </div>

        <div class="error-message" id="errorMessage"></div>

        <button class="btn btn-primary" id="processBtn" disabled>‚ú® Minimize Ink Usage</button>

        <div class="progress-container" id="progressContainer">
            <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
            <p class="progress-text" id="progressText">Processing...</p>
        </div>

        <!-- Preview Section -->
        <div class="preview-section" id="previewSection">
            <div class="preview-header">
                <span class="preview-title">üì∏ Before / After Preview</span>
                <div class="preview-nav">
                    <button id="prevPage">‚Üê</button>
                    <span class="preview-page-info" id="pageInfo">1 / 1</span>
                    <button id="nextPage">‚Üí</button>
                </div>
            </div>
            <div class="preview-container" id="previewContainer">
                <img class="preview-image before" id="previewBefore" alt="Before">
                <img class="preview-image after" id="previewAfter" alt="After">
                <div class="preview-slider" id="previewSlider"></div>
            </div>
            <div class="preview-labels">
                <span>‚óÄ Original (more ink)</span>
                <span>Optimized (less ink) ‚ñ∂</span>
            </div>
        </div>

        <div class="result-container" id="resultContainer">
            <div class="result-stats">
                <div class="stat">
                    <div class="stat-value" id="originalSize">-</div>
                    <div class="stat-label">Original</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="newSize">-</div>
                    <div class="stat-label">Optimized</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="pagesProcessed">-</div>
                    <div class="stat-label" id="pagesLabel">Pages</div>
                </div>
            </div>
            <button class="btn btn-success" id="downloadBtn">‚¨áÔ∏è Download Ink-Minimized File</button>
        </div>

        <div class="privacy-note">
            üîí <strong>100% Private:</strong> Your files are processed entirely in your browser. Nothing is uploaded to any server.
        </div>

        <div class="features">
            <div class="feature">
                <div class="feature-icon">üí∞</div>
                <div class="feature-title">Save Money</div>
                <div class="feature-desc">Reduce ink usage significantly</div>
            </div>
            <div class="feature">
                <div class="feature-icon">üîí</div>
                <div class="feature-title">100% Private</div>
                <div class="feature-desc">Files never leave your device</div>
            </div>
            <div class="feature">
                <div class="feature-icon">‚ö°</div>
                <div class="feature-title">Fast</div>
                <div class="feature-desc">Processed locally in seconds</div>
            </div>
        </div>
    </div>

    <footer>Made with ü¶Ä by <a href="https://github.com/adamantic" target="_blank">adamantic</a></footer>

    <canvas id="renderCanvas"></canvas>
    <canvas id="beforeCanvas"></canvas>
    <canvas id="tempCanvas"></canvas>

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        const uploadZone = document.getElementById('uploadZone');
        const fileInput = document.getElementById('fileInput');
        const fileInfo = document.getElementById('fileInfo');
        const fileName = document.getElementById('fileName');
        const fileSize = document.getElementById('fileSize');
        const fileType = document.getElementById('fileType');
        const processBtn = document.getElementById('processBtn');
        const progressContainer = document.getElementById('progressContainer');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        const resultContainer = document.getElementById('resultContainer');
        const downloadBtn = document.getElementById('downloadBtn');
        const errorMessage = document.getElementById('errorMessage');
        const renderCanvas = document.getElementById('renderCanvas');
        const beforeCanvas = document.getElementById('beforeCanvas');
        const tempCanvas = document.getElementById('tempCanvas');
        const ctx = renderCanvas.getContext('2d');
        const beforeCtx = beforeCanvas.getContext('2d');
        const tempCtx = tempCanvas.getContext('2d');

        const previewSection = document.getElementById('previewSection');
        const previewBefore = document.getElementById('previewBefore');
        const previewAfter = document.getElementById('previewAfter');
        const previewSlider = document.getElementById('previewSlider');
        const previewContainer = document.getElementById('previewContainer');
        const pageInfo = document.getElementById('pageInfo');
        const prevPageBtn = document.getElementById('prevPage');
        const nextPageBtn = document.getElementById('nextPage');

        let selectedFile = null;
        let processedBytes = null;
        let outputType = 'pdf';
        let previewPages = [];
        let currentPreviewPage = 0;
        let processingMode = 'outline'; // 'outline' or 'threshold'

        // Mode selector
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                processingMode = btn.dataset.mode;
            });
        });

        function formatSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        function getFileType(file) {
            const name = file.name.toLowerCase();
            if (name.endsWith('.pdf')) return 'pdf';
            if (name.endsWith('.pptx')) return 'pptx';
            if (name.endsWith('.png') || name.endsWith('.jpg') || name.endsWith('.jpeg') || name.endsWith('.webp')) return 'image';
            return null;
        }

        function handleFile(file) {
            if (!file) return;
            const type = getFileType(file);
            if (!type) { showError('Please select a PDF, PowerPoint (.pptx), or image file (PNG, JPG)'); return; }
            
            selectedFile = file;
            outputType = type;
            fileName.textContent = file.name;
            fileSize.textContent = formatSize(file.size);
            const typeLabels = { pdf: 'PDF Document', pptx: 'PowerPoint Presentation', image: 'Image File' };
            fileType.textContent = typeLabels[type] || type.toUpperCase();
            fileInfo.classList.add('visible');
            uploadZone.classList.add('has-file');
            processBtn.disabled = false;
            hideError();
            resultContainer.classList.remove('visible');
            previewSection.classList.remove('visible');
            previewPages = [];
        }

        function showError(msg) { errorMessage.textContent = msg; errorMessage.classList.add('visible'); }
        function hideError() { errorMessage.classList.remove('visible'); }
        function updateProgress(percent, text) { progressFill.style.width = percent + '%'; progressText.textContent = text; }

        // Simple threshold - convert to B&W
        function applyThreshold(imageData, threshold = 180) {
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
                const value = gray > threshold ? 255 : 0;
                data[i] = value; data[i + 1] = value; data[i + 2] = value;
            }
            return imageData;
        }

        // Sobel edge detection - outline mode
        function applyEdgeDetection(sourceCtx, destCtx, width, height) {
            const imageData = sourceCtx.getImageData(0, 0, width, height);
            const data = imageData.data;
            
            // Convert to grayscale first
            const gray = new Float32Array(width * height);
            for (let i = 0; i < data.length; i += 4) {
                const idx = i / 4;
                gray[idx] = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
            }

            // Sobel kernels
            const sobelX = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
            const sobelY = [-1, -2, -1, 0, 0, 0, 1, 2, 1];

            const output = new Uint8ClampedArray(data.length);
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    let gx = 0, gy = 0;
                    
                    // Apply Sobel kernels
                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            const idx = (y + ky) * width + (x + kx);
                            const kidx = (ky + 1) * 3 + (kx + 1);
                            gx += gray[idx] * sobelX[kidx];
                            gy += gray[idx] * sobelY[kidx];
                        }
                    }
                    
                    // Magnitude
                    const magnitude = Math.sqrt(gx * gx + gy * gy);
                    
                    // Threshold and invert (edges = black, background = white)
                    const outIdx = (y * width + x) * 4;
                    const edgeValue = magnitude > 30 ? 0 : 255; // Black edges on white
                    output[outIdx] = edgeValue;
                    output[outIdx + 1] = edgeValue;
                    output[outIdx + 2] = edgeValue;
                    output[outIdx + 3] = 255;
                }
            }
            
            // Fill edges (first/last row/col) with white
            for (let x = 0; x < width; x++) {
                const top = x * 4;
                const bottom = ((height - 1) * width + x) * 4;
                output[top] = output[top + 1] = output[top + 2] = 255; output[top + 3] = 255;
                output[bottom] = output[bottom + 1] = output[bottom + 2] = 255; output[bottom + 3] = 255;
            }
            for (let y = 0; y < height; y++) {
                const left = (y * width) * 4;
                const right = (y * width + width - 1) * 4;
                output[left] = output[left + 1] = output[left + 2] = 255; output[left + 3] = 255;
                output[right] = output[right + 1] = output[right + 2] = 255; output[right + 3] = 255;
            }

            const outputData = new ImageData(output, width, height);
            destCtx.putImageData(outputData, 0, 0);
        }

        // Process image based on current mode
        function processImage(sourceCtx, destCtx, width, height) {
            if (processingMode === 'outline') {
                applyEdgeDetection(sourceCtx, destCtx, width, height);
            } else {
                const imageData = sourceCtx.getImageData(0, 0, width, height);
                applyThreshold(imageData);
                destCtx.putImageData(imageData, 0, 0);
            }
        }

        function showPreview(pageIndex) {
            if (previewPages.length === 0) return;
            currentPreviewPage = Math.max(0, Math.min(pageIndex, previewPages.length - 1));
            previewBefore.src = previewPages[currentPreviewPage].before;
            previewAfter.src = previewPages[currentPreviewPage].after;
            pageInfo.textContent = `${currentPreviewPage + 1} / ${previewPages.length}`;
            prevPageBtn.disabled = currentPreviewPage === 0;
            nextPageBtn.disabled = currentPreviewPage === previewPages.length - 1;
            previewSection.classList.add('visible');
        }

        // Slider logic
        let isDragging = false;
        previewSlider.addEventListener('mousedown', () => isDragging = true);
        previewSlider.addEventListener('touchstart', () => isDragging = true);
        document.addEventListener('mouseup', () => isDragging = false);
        document.addEventListener('touchend', () => isDragging = false);
        
        function updateSlider(clientX) {
            const rect = previewContainer.getBoundingClientRect();
            let x = (clientX - rect.left) / rect.width * 100;
            x = Math.max(0, Math.min(100, x));
            previewSlider.style.left = x + '%';
            previewAfter.style.clipPath = `inset(0 0 0 ${x}%)`;
        }
        
        previewContainer.addEventListener('mousemove', (e) => { if (isDragging) updateSlider(e.clientX); });
        previewContainer.addEventListener('touchmove', (e) => { if (isDragging) updateSlider(e.touches[0].clientX); });
        previewContainer.addEventListener('click', (e) => updateSlider(e.clientX));

        prevPageBtn.addEventListener('click', () => showPreview(currentPreviewPage - 1));
        nextPageBtn.addEventListener('click', () => showPreview(currentPreviewPage + 1));

        async function processImageBlob(blob) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    tempCanvas.width = img.width;
                    tempCanvas.height = img.height;
                    tempCtx.drawImage(img, 0, 0);
                    
                    renderCanvas.width = img.width;
                    renderCanvas.height = img.height;
                    
                    processImage(tempCtx, ctx, img.width, img.height);
                    
                    renderCanvas.toBlob(resolve, 'image/png');
                };
                img.onerror = reject;
                img.src = URL.createObjectURL(blob);
            });
        }

        async function processPDF() {
            const arrayBuffer = await selectedFile.arrayBuffer();
            const pdfDoc = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            const numPages = pdfDoc.numPages;
            updateProgress(10, `Processing ${numPages} pages...`);

            const newPdf = await PDFLib.PDFDocument.create();
            const scale = 2;
            previewPages = [];

            for (let pageNum = 1; pageNum <= numPages; pageNum++) {
                const progress = 10 + (pageNum / numPages) * 80;
                updateProgress(progress, `Processing page ${pageNum} of ${numPages}...`);

                const page = await pdfDoc.getPage(pageNum);
                const viewport = page.getViewport({ scale });

                // Render original
                beforeCanvas.width = viewport.width;
                beforeCanvas.height = viewport.height;
                await page.render({ canvasContext: beforeCtx, viewport: viewport }).promise;
                const beforeDataUrl = beforeCanvas.toDataURL('image/png');

                // Render to temp canvas then process
                tempCanvas.width = viewport.width;
                tempCanvas.height = viewport.height;
                await page.render({ canvasContext: tempCtx, viewport: viewport }).promise;
                
                renderCanvas.width = viewport.width;
                renderCanvas.height = viewport.height;
                processImage(tempCtx, ctx, viewport.width, viewport.height);
                const afterDataUrl = renderCanvas.toDataURL('image/png');

                previewPages.push({ before: beforeDataUrl, after: afterDataUrl });

                const pngBytes = await fetch(afterDataUrl).then(res => res.arrayBuffer());
                const image = await newPdf.embedPng(pngBytes);
                const pdfPage = newPdf.addPage([viewport.width / scale, viewport.height / scale]);
                pdfPage.drawImage(image, { x: 0, y: 0, width: viewport.width / scale, height: viewport.height / scale });
            }

            updateProgress(95, 'Generating PDF...');
            processedBytes = await newPdf.save();
            document.getElementById('pagesProcessed').textContent = numPages;
            document.getElementById('pagesLabel').textContent = 'Pages';
            return numPages;
        }

        async function processPPTX() {
            const arrayBuffer = await selectedFile.arrayBuffer();
            const zip = await JSZip.loadAsync(arrayBuffer);
            
            const mediaFiles = [];
            zip.forEach((relativePath, file) => {
                if (relativePath.startsWith('ppt/media/') && !file.dir) {
                    const ext = relativePath.toLowerCase();
                    if (ext.endsWith('.png') || ext.endsWith('.jpg') || ext.endsWith('.jpeg')) {
                        mediaFiles.push({ path: relativePath, file: file });
                    }
                }
            });

            previewPages = [];

            if (mediaFiles.length === 0) {
                updateProgress(50, 'No images found to optimize...');
                processedBytes = new Uint8Array(arrayBuffer);
                document.getElementById('pagesProcessed').textContent = '0';
                document.getElementById('pagesLabel').textContent = 'Images';
                return 0;
            }

            updateProgress(10, `Processing ${mediaFiles.length} images...`);

            for (let i = 0; i < mediaFiles.length; i++) {
                const progress = 10 + ((i + 1) / mediaFiles.length) * 80;
                updateProgress(progress, `Processing image ${i + 1} of ${mediaFiles.length}...`);

                const { path, file } = mediaFiles[i];
                const blob = await file.async('blob');
                
                try {
                    const beforeUrl = URL.createObjectURL(blob);
                    const processedBlob = await processImageBlob(blob);
                    const afterUrl = URL.createObjectURL(processedBlob);
                    
                    previewPages.push({ before: beforeUrl, after: afterUrl });
                    
                    const processedArray = await processedBlob.arrayBuffer();
                    zip.file(path, processedArray);
                } catch (e) {
                    console.warn(`Could not process image ${path}:`, e);
                }
            }

            updateProgress(95, 'Generating PowerPoint...');
            processedBytes = await zip.generateAsync({ type: 'uint8array' });
            document.getElementById('pagesProcessed').textContent = mediaFiles.length;
            document.getElementById('pagesLabel').textContent = 'Images';
            return mediaFiles.length;
        }

        async function processImageFile() {
            updateProgress(10, 'Loading image...');
            
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = async () => {
                    try {
                        updateProgress(30, 'Processing image...');
                        
                        // Store original for preview
                        beforeCanvas.width = img.width;
                        beforeCanvas.height = img.height;
                        beforeCtx.drawImage(img, 0, 0);
                        const beforeDataUrl = beforeCanvas.toDataURL('image/png');
                        
                        // Process the image
                        tempCanvas.width = img.width;
                        tempCanvas.height = img.height;
                        tempCtx.drawImage(img, 0, 0);
                        
                        renderCanvas.width = img.width;
                        renderCanvas.height = img.height;
                        processImage(tempCtx, ctx, img.width, img.height);
                        
                        updateProgress(70, 'Generating output...');
                        const afterDataUrl = renderCanvas.toDataURL('image/png');
                        
                        previewPages = [{ before: beforeDataUrl, after: afterDataUrl }];
                        
                        // Convert to bytes
                        const response = await fetch(afterDataUrl);
                        const blob = await response.blob();
                        processedBytes = new Uint8Array(await blob.arrayBuffer());
                        
                        document.getElementById('pagesProcessed').textContent = '1';
                        document.getElementById('pagesLabel').textContent = 'Image';
                        
                        resolve(1);
                    } catch (e) {
                        reject(e);
                    }
                };
                img.onerror = () => reject(new Error('Failed to load image'));
                img.src = URL.createObjectURL(selectedFile);
            });
        }

        async function processFile() {
            if (!selectedFile) return;

            processBtn.disabled = true;
            uploadZone.classList.add('processing');
            progressContainer.classList.add('visible');
            resultContainer.classList.remove('visible');
            previewSection.classList.remove('visible');
            updateProgress(0, 'Loading file...');
            hideError();

            try {
                if (outputType === 'pdf') {
                    await processPDF();
                } else if (outputType === 'pptx') {
                    await processPPTX();
                } else if (outputType === 'image') {
                    await processImageFile();
                }

                updateProgress(100, 'Done!');

                document.getElementById('originalSize').textContent = formatSize(selectedFile.size);
                document.getElementById('newSize').textContent = formatSize(processedBytes.length);

                setTimeout(() => {
                    progressContainer.classList.remove('visible');
                    resultContainer.classList.add('visible');
                    if (previewPages.length > 0) showPreview(0);
                    uploadZone.classList.remove('processing');
                    processBtn.disabled = false;
                }, 500);

            } catch (error) {
                console.error('Error processing file:', error);
                progressContainer.classList.remove('visible');
                uploadZone.classList.remove('processing');
                showError('Error processing file: ' + error.message);
                processBtn.disabled = false;
            }
        }

        function downloadFile() {
            if (!processedBytes) return;
            const mimeTypes = { pdf: 'application/pdf', pptx: 'application/vnd.openxmlformats-officedocument.presentationml.presentation', image: 'image/png' };
            const extensions = { pdf: '.pdf', pptx: '.pptx', image: '.png' };
            const blob = new Blob([processedBytes], { type: mimeTypes[outputType] });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = selectedFile.name.replace(/\.(pdf|pptx|png|jpg|jpeg|webp)$/i, '') + '_inkmin' + extensions[outputType];
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Event listeners
        uploadZone.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', (e) => handleFile(e.target.files[0]));
        uploadZone.addEventListener('dragover', (e) => { e.preventDefault(); uploadZone.classList.add('dragover'); });
        uploadZone.addEventListener('dragleave', () => uploadZone.classList.remove('dragover'));
        uploadZone.addEventListener('drop', (e) => { e.preventDefault(); uploadZone.classList.remove('dragover'); handleFile(e.dataTransfer.files[0]); });
        processBtn.addEventListener('click', processFile);
        downloadBtn.addEventListener('click', downloadFile);
    </script>
</body>
</html>
